{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1481613740254},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1481613740255},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1481613740255},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1481613740254},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1481613740262},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1481613740258},{"_id":"source/_posts/Jquery简写.md","hash":"514b401b5b33ac48665eb9886a0a51ba560b5a78","modified":1481875213174},{"_id":"source/_posts/Namespace.md","hash":"ec70379aa4dc420f72d57fe719d4f7bebab81487","modified":1481770913438},{"_id":"source/_posts/Technical-Term.md","hash":"ebba3085964f4d5b3c60944c1f115440e65c5f66","modified":1481875087518},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1481613740243},{"_id":"source/_posts/js自执行函数.md","hash":"99af0baaa113e05394c618519c0bd6f437666494","modified":1481875304510},{"_id":"source/_posts/回调函数.md","hash":"10371de0ba975dd768072e62a622842003d476b5","modified":1481876444163},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1481613740290},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1481613740296},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1481613740290},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1481613740296},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1481613740296},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1481613740297},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1481613740297},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1481613740297},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1481613740297},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1481613740301},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1481613740298},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1481613740298},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1481613740300},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1481613740300},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1481613740296},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1481613740396},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1481613740401},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1481613740408},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1481613740401},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1481613740408},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1481613740411},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1481613740409},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1481613740411},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1481613740408},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1481613740410},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1481613740341},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1481613740342},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1481613740367},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1481613740394},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1481613740367},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1481613740336},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1481613740343},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1481613740368},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1481613740342},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1481613740387},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1481613740367},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1481613740382},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1481613740387},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1481613740390},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1481613740390},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1481613740388},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1481613740391},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1481613740391},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1481613740435},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1481613740436},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1481613740435},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1481613740438},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1481613740437},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1481613740436},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1481613740411},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1481613740415},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1481613740411},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1481613740414},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1481613740412},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1481613740412},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1481613740413},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1481613740417},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1481613740419},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1481613740417},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1481613740419},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1481613740417},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1481613740420},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1481613740418},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1481613740420},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1481613740427},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1481613740427},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1481613740430},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1481613740427},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1481613740430},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1481613740427},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1481613740422},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1481613740436},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1481613740436}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"# Jquery插件的开发包括两种：\n\n一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。\n\n## 1、类级别的插件开发\n\n类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：\n\n### 1.1 添加一个新的全局函数\n\n添加一个全局函数，我们只需如下定义：\n\n\nJava代码\n```python\njQuery.foo = function() {    \nalert('This is a test. This is only a test.');   \n};    \n```\n### 1.2 增加多个全局函数\n\n添加多个全局函数，可采用如下定义：\n\nJava代码\n```python\njQuery.foo = function() {    \nalert('This is a test. This is only a test.');   \n};   \njQuery.bar = function(param) {    \nalert('This function takes a parameter, which is \"' + param + '\".');   \n};    \n```\n调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar('bar');  \n### 1.3 使用jQuery.extend(object);　\n\nJava代码 \n```python\njQuery.extend({       \nfoo: function() {       \nalert('This is a test. This is only a test.');       \n},       \nbar: function(param) {       \nalert('This function takes a parameter, which is \"' + param +'\".');       \n}      \n});  \n```\n\n### 1.4 使用命名空间\n\n虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。\n\nJava代码\n```python\njQuery.myPlugin = {           \nfoo:function() {           \nalert('This is a test. This is only a test.');           \n},           \nbar:function(param) {           \nalert('This function takes a parameter, which is \"' + param + '\".');     \n}          \n};  \n```\n采用命名空间的函数仍然是全局函数，调用时采用的方法：   \n$.myPlugin.foo();          \n$.myPlugin.bar('baz');  \n \n\n通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。\n\n## 2、对象级别的插件开发\n\n对象级别的插件开发需要如下的两种形式：、\n\n形式1：  \n\nJava代码\n```python\n(function($){      \n$.fn.extend({      \npluginName:function(opt,callback){      \n /*Our plugin implementation code goes here.  */      \n}      \n})      \n})(jQuery);   \n```\n形式2：\n \n\nJava代码\n```python\n(function($) {        \n$.fn.pluginName = function() {      \n/* Our plugin implementation code goes here. \n};      \n})(jQuery);   \n```\n上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.\n### 2.1 在JQuery名称空间下申明一个名字\n\n这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和 $.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“    \n\n \n\nJava代码\n```python\n$.fn.hilight = function() {     \n  // Our plugin implementation code goes here.     \n};     \n```\n我们的插件通过这样被调用：   \n$('#myDiv').hilight();     \n \n\n但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在\"hilight\" 函数中被声明属性。稍后继续。\n### 2.2 接受options参数以控制插件的行为\n\n让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：   \n\nJava代码\n```python\n// plugin definition     \n$.fn.hilight = function(options) {     \n  var defaults = {     \n    foreground: 'red',     \n    background: 'yellow'     \n  };     \n  // Extend our default options with those provided.     \n  var opts = $.extend(defaults, options);     \n  // Our plugin implementation code goes here.     \n};    \n```\n我们的插件可以这样被调用：  \n```python\n$('#myDiv').hilight({     \n  foreground: 'blue'     \n});     \n```\n\n### 2.3 暴露插件的默认设置\n\n我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。     \n \n\nJava代码\n```python\n// plugin definition     \n$.fn.hilight = function(options) {     \n  // Extend our default options with those provided.     \n  // Note that the first arg to extend is an empty object -     \n  // this is to keep from overriding our \"defaults\" object.     \n  var opts = $.extend({}, $.fn.hilight.defaults, options);     \n  // Our plugin implementation code goes here.     \n};     \n// plugin defaults - added as a property on our plugin function     \n$.fn.hilight.defaults = {     \n  foreground: 'red',     \n  background: 'yellow'     \n};  \n```\n现在使用者可以包含像这样的一行在他们的脚本里：   \n//这个只需要调用一次，且不一定要在ready块中调用   \n$.fn.hilight.defaults.foreground = 'blue';     \n接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：   \n$('#myDiv').hilight();   \n \n\n如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：\n```python\n// 覆盖插件缺省的背景颜色 \n\n$.fn.hilight.defaults.foreground = 'blue'; \n\n// ... \n\n// 使用一个新的缺省设置调用插件 \n\n$('.hilightDiv').hilight(); \n\n// ... \n\n// 通过传递配置参数给插件方法来覆盖缺省设置 \n\n$('#green').hilight({ \n\n foreground: 'green' \n\n});  \n```\n\n### 2.4 适当的暴露一些函数\n\n这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫\"format\"的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。\n\nJava代码\n```python\n// plugin definition     \n$.fn.hilight = function(options) {     \n  // iterate and reformat each matched element     \n  return this.each(function() {     \n    var $this = $(this);     \n    // ...     \n    var markup = $this.html();     \n    // call our format function     \n    markup = $.fn.hilight.format(markup);     \n    $this.html(markup);     \n  });     \n};     \n// define our format function     \n$.fn.hilight.format = function(txt) {     \nreturn '<strong>' + txt + '</strong>';     \n};   \n```\n我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。 \n考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露\"transitions\"对象，使他们添加自己变换定义。插件中定义就像这样：\n$.fn.cycle.transitions = { \n\n// ... \n\n}; \n\n这个技巧使其他人能定义和传递变换设置到Cycle插件。\n\n### 2.5 保持私有函数的私有性\n\n这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。\n\n那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。 \n\nJava代码\n```python\n (function($) {     \n  // plugin definition     \n  $.fn.hilight = function(options) {     \n    debug(this);     \n   // ...     \n  };     \n  // private function for debugging     \n  function debug($obj) {     \n    if (window.console && window.console.log)     \n    window.console.log('hilight selection count: ' + $obj.size());     \n  };     \n//  ...     \n})(jQuery);    \n```\n\n我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。\n### 2.6 支持Metadata插件\n\n在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的\"markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。\n\nJava代码\n```python\n$.fn.hilight = function(options) {     \n  // ...     \n  // build main options before element iteration     \n  var opts = $.extend({}, $.fn.hilight.defaults, options);     \n  return this.each(function() {     \n    var $this = $(this);     \n    // build element specific options     \n    var o = $.meta ? $.extend({}, opts, $this.data()) : opts;     \n    //...   \n```\n 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从\"markup”处驱动行为,如果我们选择了“markup”：\n\n 调用的时候可以这样写： jQuery.foo(); 或 $.foo(); \n\n \n\nJava代码\n```python\n<!--  markup  -->     \n<div class=\"hilight { background: 'red', foreground: 'white' }\">     \n  Have a nice day!     \n</div>     \n<div class=\"hilight { foreground: 'orange' }\">     \n  Have a nice day!     \n</div>     \n<div class=\"hilight { background: 'green' }\">     \n  Have a nice day!     \n</div>     \n```\n现在我们能高亮哪些div仅使用一行脚本：   \n$('.hilight').hilight();     \n \n\n### 2.7 整合\n下面使我们的例子完成后的代码：\n\n    \n\nJava代码\n```python\n// 创建一个闭包     \n(function($) {     \n  // 插件的定义     \n  $.fn.hilight = function(options) {     \n    debug(this);     \n    // build main options before element iteration     \n    var opts = $.extend({}, $.fn.hilight.defaults, options);     \n    // iterate and reformat each matched element     \n    return this.each(function() {     \n    $this = $(this);     \n // build element specific options     \n var o = $.meta ? $.extend({}, opts, $this.data()) : opts;     \n // update element styles     \n$this.css({     \n   backgroundColor: o.background,     \n  color: o.foreground     \n  });     \n  var markup = $this.html();     \n   // call our format function     \n markup = $.fn.hilight.format(markup);     \n $this.html(markup);     \n    });     \n  };     \n  // 私有函数：debugging     \n  function debug($obj) {     \n    if (window.console && window.console.log)     \n      window.console.log('hilight selection count: ' + $obj.size());     \n  };     \n  // 定义暴露format函数     \n  $.fn.hilight.format = function(txt) {     \n    return '<strong>' + txt + '</strong>';     \n  };     \n  // 插件的defaults     \n  $.fn.hilight.defaults = {     \n    foreground: 'red',     \n    background: 'yellow'     \n  };     \n// 闭包结束     \n})(jQuery);     \n```\n\n这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。","source":"_posts/Namespace.md","raw":"# Jquery插件的开发包括两种：\n\n一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。\n\n## 1、类级别的插件开发\n\n类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：\n\n### 1.1 添加一个新的全局函数\n\n添加一个全局函数，我们只需如下定义：\n\n\nJava代码\n```python\njQuery.foo = function() {    \nalert('This is a test. This is only a test.');   \n};    \n```\n### 1.2 增加多个全局函数\n\n添加多个全局函数，可采用如下定义：\n\nJava代码\n```python\njQuery.foo = function() {    \nalert('This is a test. This is only a test.');   \n};   \njQuery.bar = function(param) {    \nalert('This function takes a parameter, which is \"' + param + '\".');   \n};    \n```\n调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar('bar');  \n### 1.3 使用jQuery.extend(object);　\n\nJava代码 \n```python\njQuery.extend({       \nfoo: function() {       \nalert('This is a test. This is only a test.');       \n},       \nbar: function(param) {       \nalert('This function takes a parameter, which is \"' + param +'\".');       \n}      \n});  \n```\n\n### 1.4 使用命名空间\n\n虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。\n\nJava代码\n```python\njQuery.myPlugin = {           \nfoo:function() {           \nalert('This is a test. This is only a test.');           \n},           \nbar:function(param) {           \nalert('This function takes a parameter, which is \"' + param + '\".');     \n}          \n};  \n```\n采用命名空间的函数仍然是全局函数，调用时采用的方法：   \n$.myPlugin.foo();          \n$.myPlugin.bar('baz');  \n \n\n通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。\n\n## 2、对象级别的插件开发\n\n对象级别的插件开发需要如下的两种形式：、\n\n形式1：  \n\nJava代码\n```python\n(function($){      \n$.fn.extend({      \npluginName:function(opt,callback){      \n /*Our plugin implementation code goes here.  */      \n}      \n})      \n})(jQuery);   \n```\n形式2：\n \n\nJava代码\n```python\n(function($) {        \n$.fn.pluginName = function() {      \n/* Our plugin implementation code goes here. \n};      \n})(jQuery);   \n```\n上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.\n### 2.1 在JQuery名称空间下申明一个名字\n\n这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和 $.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“    \n\n \n\nJava代码\n```python\n$.fn.hilight = function() {     \n  // Our plugin implementation code goes here.     \n};     \n```\n我们的插件通过这样被调用：   \n$('#myDiv').hilight();     \n \n\n但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在\"hilight\" 函数中被声明属性。稍后继续。\n### 2.2 接受options参数以控制插件的行为\n\n让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：   \n\nJava代码\n```python\n// plugin definition     \n$.fn.hilight = function(options) {     \n  var defaults = {     \n    foreground: 'red',     \n    background: 'yellow'     \n  };     \n  // Extend our default options with those provided.     \n  var opts = $.extend(defaults, options);     \n  // Our plugin implementation code goes here.     \n};    \n```\n我们的插件可以这样被调用：  \n```python\n$('#myDiv').hilight({     \n  foreground: 'blue'     \n});     \n```\n\n### 2.3 暴露插件的默认设置\n\n我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。     \n \n\nJava代码\n```python\n// plugin definition     \n$.fn.hilight = function(options) {     \n  // Extend our default options with those provided.     \n  // Note that the first arg to extend is an empty object -     \n  // this is to keep from overriding our \"defaults\" object.     \n  var opts = $.extend({}, $.fn.hilight.defaults, options);     \n  // Our plugin implementation code goes here.     \n};     \n// plugin defaults - added as a property on our plugin function     \n$.fn.hilight.defaults = {     \n  foreground: 'red',     \n  background: 'yellow'     \n};  \n```\n现在使用者可以包含像这样的一行在他们的脚本里：   \n//这个只需要调用一次，且不一定要在ready块中调用   \n$.fn.hilight.defaults.foreground = 'blue';     \n接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：   \n$('#myDiv').hilight();   \n \n\n如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：\n```python\n// 覆盖插件缺省的背景颜色 \n\n$.fn.hilight.defaults.foreground = 'blue'; \n\n// ... \n\n// 使用一个新的缺省设置调用插件 \n\n$('.hilightDiv').hilight(); \n\n// ... \n\n// 通过传递配置参数给插件方法来覆盖缺省设置 \n\n$('#green').hilight({ \n\n foreground: 'green' \n\n});  \n```\n\n### 2.4 适当的暴露一些函数\n\n这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫\"format\"的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。\n\nJava代码\n```python\n// plugin definition     \n$.fn.hilight = function(options) {     \n  // iterate and reformat each matched element     \n  return this.each(function() {     \n    var $this = $(this);     \n    // ...     \n    var markup = $this.html();     \n    // call our format function     \n    markup = $.fn.hilight.format(markup);     \n    $this.html(markup);     \n  });     \n};     \n// define our format function     \n$.fn.hilight.format = function(txt) {     \nreturn '<strong>' + txt + '</strong>';     \n};   \n```\n我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。 \n考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露\"transitions\"对象，使他们添加自己变换定义。插件中定义就像这样：\n$.fn.cycle.transitions = { \n\n// ... \n\n}; \n\n这个技巧使其他人能定义和传递变换设置到Cycle插件。\n\n### 2.5 保持私有函数的私有性\n\n这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。\n\n那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。 \n\nJava代码\n```python\n (function($) {     \n  // plugin definition     \n  $.fn.hilight = function(options) {     \n    debug(this);     \n   // ...     \n  };     \n  // private function for debugging     \n  function debug($obj) {     \n    if (window.console && window.console.log)     \n    window.console.log('hilight selection count: ' + $obj.size());     \n  };     \n//  ...     \n})(jQuery);    \n```\n\n我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。\n### 2.6 支持Metadata插件\n\n在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的\"markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。\n\nJava代码\n```python\n$.fn.hilight = function(options) {     \n  // ...     \n  // build main options before element iteration     \n  var opts = $.extend({}, $.fn.hilight.defaults, options);     \n  return this.each(function() {     \n    var $this = $(this);     \n    // build element specific options     \n    var o = $.meta ? $.extend({}, opts, $this.data()) : opts;     \n    //...   \n```\n 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从\"markup”处驱动行为,如果我们选择了“markup”：\n\n 调用的时候可以这样写： jQuery.foo(); 或 $.foo(); \n\n \n\nJava代码\n```python\n<!--  markup  -->     \n<div class=\"hilight { background: 'red', foreground: 'white' }\">     \n  Have a nice day!     \n</div>     \n<div class=\"hilight { foreground: 'orange' }\">     \n  Have a nice day!     \n</div>     \n<div class=\"hilight { background: 'green' }\">     \n  Have a nice day!     \n</div>     \n```\n现在我们能高亮哪些div仅使用一行脚本：   \n$('.hilight').hilight();     \n \n\n### 2.7 整合\n下面使我们的例子完成后的代码：\n\n    \n\nJava代码\n```python\n// 创建一个闭包     \n(function($) {     \n  // 插件的定义     \n  $.fn.hilight = function(options) {     \n    debug(this);     \n    // build main options before element iteration     \n    var opts = $.extend({}, $.fn.hilight.defaults, options);     \n    // iterate and reformat each matched element     \n    return this.each(function() {     \n    $this = $(this);     \n // build element specific options     \n var o = $.meta ? $.extend({}, opts, $this.data()) : opts;     \n // update element styles     \n$this.css({     \n   backgroundColor: o.background,     \n  color: o.foreground     \n  });     \n  var markup = $this.html();     \n   // call our format function     \n markup = $.fn.hilight.format(markup);     \n $this.html(markup);     \n    });     \n  };     \n  // 私有函数：debugging     \n  function debug($obj) {     \n    if (window.console && window.console.log)     \n      window.console.log('hilight selection count: ' + $obj.size());     \n  };     \n  // 定义暴露format函数     \n  $.fn.hilight.format = function(txt) {     \n    return '<strong>' + txt + '</strong>';     \n  };     \n  // 插件的defaults     \n  $.fn.hilight.defaults = {     \n    foreground: 'red',     \n    background: 'yellow'     \n  };     \n// 闭包结束     \n})(jQuery);     \n```\n\n这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。","slug":"Namespace","published":1,"date":"2016-12-15T01:52:09.741Z","updated":"2016-12-15T03:01:53.438Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwriz7zw0000tojoeeln8bt7","content":"<h1 id=\"Jquery插件的开发包括两种：\"><a href=\"#Jquery插件的开发包括两种：\" class=\"headerlink\" title=\"Jquery插件的开发包括两种：\"></a>Jquery插件的开发包括两种：</h1><p>一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。</p>\n<h2 id=\"1、类级别的插件开发\"><a href=\"#1、类级别的插件开发\" class=\"headerlink\" title=\"1、类级别的插件开发\"></a>1、类级别的插件开发</h2><p>类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：</p>\n<h3 id=\"1-1-添加一个新的全局函数\"><a href=\"#1-1-添加一个新的全局函数\" class=\"headerlink\" title=\"1.1 添加一个新的全局函数\"></a>1.1 添加一个新的全局函数</h3><p>添加一个全局函数，我们只需如下定义：</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.foo = function() &#123;    </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);   </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-增加多个全局函数\"><a href=\"#1-2-增加多个全局函数\" class=\"headerlink\" title=\"1.2 增加多个全局函数\"></a>1.2 增加多个全局函数</h3><p>添加多个全局函数，可采用如下定义：</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.foo = function() &#123;    </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);   </div><div class=\"line\">&#125;;   </div><div class=\"line\">jQuery.bar = function(param) &#123;    </div><div class=\"line\">alert(<span class=\"string\">'This function takes a parameter, which is \"'</span> + param + <span class=\"string\">'\".'</span>);   </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar(‘bar’);  </p>\n<h3 id=\"1-3-使用jQuery-extend-object\"><a href=\"#1-3-使用jQuery-extend-object\" class=\"headerlink\" title=\"1.3 使用jQuery.extend(object);　\"></a>1.3 使用jQuery.extend(object);　</h3><p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.extend(&#123;       </div><div class=\"line\">foo: function() &#123;       </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);       </div><div class=\"line\">&#125;,       </div><div class=\"line\">bar: function(param) &#123;       </div><div class=\"line\">alert(<span class=\"string\">'This function takes a parameter, which is \"'</span> + param +<span class=\"string\">'\".'</span>);       </div><div class=\"line\">&#125;      </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-4-使用命名空间\"><a href=\"#1-4-使用命名空间\" class=\"headerlink\" title=\"1.4 使用命名空间\"></a>1.4 使用命名空间</h3><p>虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.myPlugin = &#123;           </div><div class=\"line\">foo:function() &#123;           </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);           </div><div class=\"line\">&#125;,           </div><div class=\"line\">bar:function(param) &#123;           </div><div class=\"line\">alert(<span class=\"string\">'This function takes a parameter, which is \"'</span> + param + <span class=\"string\">'\".'</span>);     </div><div class=\"line\">&#125;          </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>采用命名空间的函数仍然是全局函数，调用时采用的方法：<br>$.myPlugin.foo();<br>$.myPlugin.bar(‘baz’);  </p>\n<p>通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。</p>\n<h2 id=\"2、对象级别的插件开发\"><a href=\"#2、对象级别的插件开发\" class=\"headerlink\" title=\"2、对象级别的插件开发\"></a>2、对象级别的插件开发</h2><p>对象级别的插件开发需要如下的两种形式：、</p>\n<p>形式1：  </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function($)&#123;      </div><div class=\"line\">$.fn.extend(&#123;      </div><div class=\"line\">pluginName:function(opt,callback)&#123;      </div><div class=\"line\"> /*Our plugin implementation code goes here.  */      </div><div class=\"line\">&#125;      </div><div class=\"line\">&#125;)      </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>形式2：</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function($) &#123;        </div><div class=\"line\">$.fn.pluginName = function() &#123;      </div><div class=\"line\">/* Our plugin implementation code goes here. </div><div class=\"line\">&#125;;      </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.</p>\n<h3 id=\"2-1-在JQuery名称空间下申明一个名字\"><a href=\"#2-1-在JQuery名称空间下申明一个名字\" class=\"headerlink\" title=\"2.1 在JQuery名称空间下申明一个名字\"></a>2.1 在JQuery名称空间下申明一个名字</h3><p>这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和 $.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“    </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.fn.hilight = function() &#123;     </div><div class=\"line\">  // Our plugin implementation code goes here.     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们的插件通过这样被调用：<br>$(‘#myDiv’).hilight();     </p>\n<p>但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在”hilight” 函数中被声明属性。稍后继续。</p>\n<h3 id=\"2-2-接受options参数以控制插件的行为\"><a href=\"#2-2-接受options参数以控制插件的行为\" class=\"headerlink\" title=\"2.2 接受options参数以控制插件的行为\"></a>2.2 接受options参数以控制插件的行为</h3><p>让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：   </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// plugin definition     </div><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  var defaults = &#123;     </div><div class=\"line\">    foreground: <span class=\"string\">'red'</span>,     </div><div class=\"line\">    background: <span class=\"string\">'yellow'</span>     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // Extend our default options <span class=\"keyword\">with</span> those provided.     </div><div class=\"line\">  var opts = $.extend(defaults, options);     </div><div class=\"line\">  // Our plugin implementation code goes here.     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们的插件可以这样被调用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#myDiv'</span>).hilight(&#123;     </div><div class=\"line\">  foreground: <span class=\"string\">'blue'</span>     </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-暴露插件的默认设置\"><a href=\"#2-3-暴露插件的默认设置\" class=\"headerlink\" title=\"2.3 暴露插件的默认设置\"></a>2.3 暴露插件的默认设置</h3><p>我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。     </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// plugin definition     </div><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  // Extend our default options <span class=\"keyword\">with</span> those provided.     </div><div class=\"line\">  // Note that the first arg to extend <span class=\"keyword\">is</span> an empty object -     </div><div class=\"line\">  // this <span class=\"keyword\">is</span> to keep <span class=\"keyword\">from</span> overriding our <span class=\"string\">\"defaults\"</span> object.     </div><div class=\"line\">  var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);     </div><div class=\"line\">  // Our plugin implementation code goes here.     </div><div class=\"line\">&#125;;     </div><div class=\"line\">// plugin defaults - added <span class=\"keyword\">as</span> a property on our plugin function     </div><div class=\"line\">$.fn.hilight.defaults = &#123;     </div><div class=\"line\">  foreground: <span class=\"string\">'red'</span>,     </div><div class=\"line\">  background: <span class=\"string\">'yellow'</span>     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>现在使用者可以包含像这样的一行在他们的脚本里：<br>//这个只需要调用一次，且不一定要在ready块中调用<br>$.fn.hilight.defaults.foreground = ‘blue’;<br>接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：<br>$(‘#myDiv’).hilight();   </p>\n<p>如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 覆盖插件缺省的背景颜色 </div><div class=\"line\"></div><div class=\"line\">$.fn.hilight.defaults.foreground = <span class=\"string\">'blue'</span>; </div><div class=\"line\"></div><div class=\"line\">// ... </div><div class=\"line\"></div><div class=\"line\">// 使用一个新的缺省设置调用插件 </div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'.hilightDiv'</span>).hilight(); </div><div class=\"line\"></div><div class=\"line\">// ... </div><div class=\"line\"></div><div class=\"line\">// 通过传递配置参数给插件方法来覆盖缺省设置 </div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'#green'</span>).hilight(&#123; </div><div class=\"line\"></div><div class=\"line\"> foreground: <span class=\"string\">'green'</span> </div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-4-适当的暴露一些函数\"><a href=\"#2-4-适当的暴露一些函数\" class=\"headerlink\" title=\"2.4 适当的暴露一些函数\"></a>2.4 适当的暴露一些函数</h3><p>这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫”format”的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// plugin definition     </div><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  // iterate <span class=\"keyword\">and</span> reformat each matched element     </div><div class=\"line\">  <span class=\"keyword\">return</span> this.each(function() &#123;     </div><div class=\"line\">    var $this = $(this);     </div><div class=\"line\">    // ...     </div><div class=\"line\">    var markup = $this.html();     </div><div class=\"line\">    // call our format function     </div><div class=\"line\">    markup = $.fn.hilight.format(markup);     </div><div class=\"line\">    $this.html(markup);     </div><div class=\"line\">  &#125;);     </div><div class=\"line\">&#125;;     </div><div class=\"line\">// define our format function     </div><div class=\"line\">$.fn.hilight.format = function(txt) &#123;     </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">'&lt;strong&gt;'</span> + txt + <span class=\"string\">'&lt;/strong&gt;'</span>;     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。<br>考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露”transitions”对象，使他们添加自己变换定义。插件中定义就像这样：<br>$.fn.cycle.transitions = { </p>\n<p>// … </p>\n<p>}; </p>\n<p>这个技巧使其他人能定义和传递变换设置到Cycle插件。</p>\n<h3 id=\"2-5-保持私有函数的私有性\"><a href=\"#2-5-保持私有函数的私有性\" class=\"headerlink\" title=\"2.5 保持私有函数的私有性\"></a>2.5 保持私有函数的私有性</h3><p>这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。</p>\n<p>那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。 </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (function($) &#123;     </div><div class=\"line\">  // plugin definition     </div><div class=\"line\">  $.fn.hilight = function(options) &#123;     </div><div class=\"line\">    debug(this);     </div><div class=\"line\">   // ...     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // private function <span class=\"keyword\">for</span> debugging     </div><div class=\"line\">  function debug($obj) &#123;     </div><div class=\"line\">    <span class=\"keyword\">if</span> (window.console &amp;&amp; window.console.log)     </div><div class=\"line\">    window.console.log(<span class=\"string\">'hilight selection count: '</span> + $obj.size());     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">//  ...     </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。</p>\n<h3 id=\"2-6-支持Metadata插件\"><a href=\"#2-6-支持Metadata插件\" class=\"headerlink\" title=\"2.6 支持Metadata插件\"></a>2.6 支持Metadata插件</h3><p>在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的”markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。</p>\n<p>Java代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  // ...     </div><div class=\"line\">  // build main options before element iteration     </div><div class=\"line\">  var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);     </div><div class=\"line\">  return this.each(function() &#123;     </div><div class=\"line\">    var $this = $(this);     </div><div class=\"line\">    // build element specific options     </div><div class=\"line\">    var o = $.meta ? $.extend(&#123;&#125;, opts, $this.data()) : opts;     </div><div class=\"line\">    //...</div></pre></td></tr></table></figure></p>\n<p> 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从”markup”处驱动行为,如果我们选择了“markup”：</p>\n<p> 调用的时候可以这样写： jQuery.foo(); 或 $.foo(); </p>\n<p>Java代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--  markup  --&gt;     </div><div class=\"line\">&lt;div class=\"hilight &#123; background: 'red', foreground: 'white' &#125;\"&gt;     </div><div class=\"line\">  Have a nice day!     </div><div class=\"line\">&lt;/div&gt;     </div><div class=\"line\">&lt;div class=\"hilight &#123; foreground: 'orange' &#125;\"&gt;     </div><div class=\"line\">  Have a nice day!     </div><div class=\"line\">&lt;/div&gt;     </div><div class=\"line\">&lt;div class=\"hilight &#123; background: 'green' &#125;\"&gt;     </div><div class=\"line\">  Have a nice day!     </div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>现在我们能高亮哪些div仅使用一行脚本：<br>$(‘.hilight’).hilight();     </p>\n<h3 id=\"2-7-整合\"><a href=\"#2-7-整合\" class=\"headerlink\" title=\"2.7 整合\"></a>2.7 整合</h3><p>下面使我们的例子完成后的代码：</p>\n<p>Java代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建一个闭包     </div><div class=\"line\">(function($) &#123;     </div><div class=\"line\">  // 插件的定义     </div><div class=\"line\">  $.fn.hilight = function(options) &#123;     </div><div class=\"line\">    debug(this);     </div><div class=\"line\">    // build main options before element iteration     </div><div class=\"line\">    var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);     </div><div class=\"line\">    // iterate and reformat each matched element     </div><div class=\"line\">    return this.each(function() &#123;     </div><div class=\"line\">    $this = $(this);     </div><div class=\"line\"> // build element specific options     </div><div class=\"line\"> var o = $.meta ? $.extend(&#123;&#125;, opts, $this.data()) : opts;     </div><div class=\"line\"> // update element styles     </div><div class=\"line\">$this.css(&#123;     </div><div class=\"line\">   backgroundColor: o.background,     </div><div class=\"line\">  color: o.foreground     </div><div class=\"line\">  &#125;);     </div><div class=\"line\">  var markup = $this.html();     </div><div class=\"line\">   // call our format function     </div><div class=\"line\"> markup = $.fn.hilight.format(markup);     </div><div class=\"line\"> $this.html(markup);     </div><div class=\"line\">    &#125;);     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // 私有函数：debugging     </div><div class=\"line\">  function debug($obj) &#123;     </div><div class=\"line\">    if (window.console &amp;&amp; window.console.log)     </div><div class=\"line\">      window.console.log('hilight selection count: ' + $obj.size());     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // 定义暴露format函数     </div><div class=\"line\">  $.fn.hilight.format = function(txt) &#123;     </div><div class=\"line\">    return '&lt;strong&gt;' + txt + '&lt;/strong&gt;';     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // 插件的defaults     </div><div class=\"line\">  $.fn.hilight.defaults = &#123;     </div><div class=\"line\">    foreground: 'red',     </div><div class=\"line\">    background: 'yellow'     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">// 闭包结束     </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。</p>\n","excerpt":"","more":"<h1 id=\"Jquery插件的开发包括两种：\"><a href=\"#Jquery插件的开发包括两种：\" class=\"headerlink\" title=\"Jquery插件的开发包括两种：\"></a>Jquery插件的开发包括两种：</h1><p>一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。</p>\n<h2 id=\"1、类级别的插件开发\"><a href=\"#1、类级别的插件开发\" class=\"headerlink\" title=\"1、类级别的插件开发\"></a>1、类级别的插件开发</h2><p>类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：</p>\n<h3 id=\"1-1-添加一个新的全局函数\"><a href=\"#1-1-添加一个新的全局函数\" class=\"headerlink\" title=\"1.1 添加一个新的全局函数\"></a>1.1 添加一个新的全局函数</h3><p>添加一个全局函数，我们只需如下定义：</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.foo = function() &#123;    </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);   </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-增加多个全局函数\"><a href=\"#1-2-增加多个全局函数\" class=\"headerlink\" title=\"1.2 增加多个全局函数\"></a>1.2 增加多个全局函数</h3><p>添加多个全局函数，可采用如下定义：</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.foo = function() &#123;    </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);   </div><div class=\"line\">&#125;;   </div><div class=\"line\">jQuery.bar = function(param) &#123;    </div><div class=\"line\">alert(<span class=\"string\">'This function takes a parameter, which is \"'</span> + param + <span class=\"string\">'\".'</span>);   </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar(‘bar’);  </p>\n<h3 id=\"1-3-使用jQuery-extend-object\"><a href=\"#1-3-使用jQuery-extend-object\" class=\"headerlink\" title=\"1.3 使用jQuery.extend(object);　\"></a>1.3 使用jQuery.extend(object);　</h3><p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.extend(&#123;       </div><div class=\"line\">foo: function() &#123;       </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);       </div><div class=\"line\">&#125;,       </div><div class=\"line\">bar: function(param) &#123;       </div><div class=\"line\">alert(<span class=\"string\">'This function takes a parameter, which is \"'</span> + param +<span class=\"string\">'\".'</span>);       </div><div class=\"line\">&#125;      </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"1-4-使用命名空间\"><a href=\"#1-4-使用命名空间\" class=\"headerlink\" title=\"1.4 使用命名空间\"></a>1.4 使用命名空间</h3><p>虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.myPlugin = &#123;           </div><div class=\"line\">foo:function() &#123;           </div><div class=\"line\">alert(<span class=\"string\">'This is a test. This is only a test.'</span>);           </div><div class=\"line\">&#125;,           </div><div class=\"line\">bar:function(param) &#123;           </div><div class=\"line\">alert(<span class=\"string\">'This function takes a parameter, which is \"'</span> + param + <span class=\"string\">'\".'</span>);     </div><div class=\"line\">&#125;          </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>采用命名空间的函数仍然是全局函数，调用时采用的方法：<br>$.myPlugin.foo();<br>$.myPlugin.bar(‘baz’);  </p>\n<p>通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。</p>\n<h2 id=\"2、对象级别的插件开发\"><a href=\"#2、对象级别的插件开发\" class=\"headerlink\" title=\"2、对象级别的插件开发\"></a>2、对象级别的插件开发</h2><p>对象级别的插件开发需要如下的两种形式：、</p>\n<p>形式1：  </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function($)&#123;      </div><div class=\"line\">$.fn.extend(&#123;      </div><div class=\"line\">pluginName:function(opt,callback)&#123;      </div><div class=\"line\"> /*Our plugin implementation code goes here.  */      </div><div class=\"line\">&#125;      </div><div class=\"line\">&#125;)      </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>形式2：</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function($) &#123;        </div><div class=\"line\">$.fn.pluginName = function() &#123;      </div><div class=\"line\">/* Our plugin implementation code goes here. </div><div class=\"line\">&#125;;      </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.</p>\n<h3 id=\"2-1-在JQuery名称空间下申明一个名字\"><a href=\"#2-1-在JQuery名称空间下申明一个名字\" class=\"headerlink\" title=\"2.1 在JQuery名称空间下申明一个名字\"></a>2.1 在JQuery名称空间下申明一个名字</h3><p>这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和 $.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“    </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.fn.hilight = function() &#123;     </div><div class=\"line\">  // Our plugin implementation code goes here.     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们的插件通过这样被调用：<br>$(‘#myDiv’).hilight();     </p>\n<p>但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在”hilight” 函数中被声明属性。稍后继续。</p>\n<h3 id=\"2-2-接受options参数以控制插件的行为\"><a href=\"#2-2-接受options参数以控制插件的行为\" class=\"headerlink\" title=\"2.2 接受options参数以控制插件的行为\"></a>2.2 接受options参数以控制插件的行为</h3><p>让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：   </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// plugin definition     </div><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  var defaults = &#123;     </div><div class=\"line\">    foreground: <span class=\"string\">'red'</span>,     </div><div class=\"line\">    background: <span class=\"string\">'yellow'</span>     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // Extend our default options <span class=\"keyword\">with</span> those provided.     </div><div class=\"line\">  var opts = $.extend(defaults, options);     </div><div class=\"line\">  // Our plugin implementation code goes here.     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们的插件可以这样被调用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#myDiv'</span>).hilight(&#123;     </div><div class=\"line\">  foreground: <span class=\"string\">'blue'</span>     </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-暴露插件的默认设置\"><a href=\"#2-3-暴露插件的默认设置\" class=\"headerlink\" title=\"2.3 暴露插件的默认设置\"></a>2.3 暴露插件的默认设置</h3><p>我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。     </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// plugin definition     </div><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  // Extend our default options <span class=\"keyword\">with</span> those provided.     </div><div class=\"line\">  // Note that the first arg to extend <span class=\"keyword\">is</span> an empty object -     </div><div class=\"line\">  // this <span class=\"keyword\">is</span> to keep <span class=\"keyword\">from</span> overriding our <span class=\"string\">\"defaults\"</span> object.     </div><div class=\"line\">  var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);     </div><div class=\"line\">  // Our plugin implementation code goes here.     </div><div class=\"line\">&#125;;     </div><div class=\"line\">// plugin defaults - added <span class=\"keyword\">as</span> a property on our plugin function     </div><div class=\"line\">$.fn.hilight.defaults = &#123;     </div><div class=\"line\">  foreground: <span class=\"string\">'red'</span>,     </div><div class=\"line\">  background: <span class=\"string\">'yellow'</span>     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>现在使用者可以包含像这样的一行在他们的脚本里：<br>//这个只需要调用一次，且不一定要在ready块中调用<br>$.fn.hilight.defaults.foreground = ‘blue’;<br>接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：<br>$(‘#myDiv’).hilight();   </p>\n<p>如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 覆盖插件缺省的背景颜色 </div><div class=\"line\"></div><div class=\"line\">$.fn.hilight.defaults.foreground = <span class=\"string\">'blue'</span>; </div><div class=\"line\"></div><div class=\"line\">// ... </div><div class=\"line\"></div><div class=\"line\">// 使用一个新的缺省设置调用插件 </div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'.hilightDiv'</span>).hilight(); </div><div class=\"line\"></div><div class=\"line\">// ... </div><div class=\"line\"></div><div class=\"line\">// 通过传递配置参数给插件方法来覆盖缺省设置 </div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'#green'</span>).hilight(&#123; </div><div class=\"line\"></div><div class=\"line\"> foreground: <span class=\"string\">'green'</span> </div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-4-适当的暴露一些函数\"><a href=\"#2-4-适当的暴露一些函数\" class=\"headerlink\" title=\"2.4 适当的暴露一些函数\"></a>2.4 适当的暴露一些函数</h3><p>这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫”format”的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。</p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// plugin definition     </div><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  // iterate <span class=\"keyword\">and</span> reformat each matched element     </div><div class=\"line\">  <span class=\"keyword\">return</span> this.each(function() &#123;     </div><div class=\"line\">    var $this = $(this);     </div><div class=\"line\">    // ...     </div><div class=\"line\">    var markup = $this.html();     </div><div class=\"line\">    // call our format function     </div><div class=\"line\">    markup = $.fn.hilight.format(markup);     </div><div class=\"line\">    $this.html(markup);     </div><div class=\"line\">  &#125;);     </div><div class=\"line\">&#125;;     </div><div class=\"line\">// define our format function     </div><div class=\"line\">$.fn.hilight.format = function(txt) &#123;     </div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">'&lt;strong&gt;'</span> + txt + <span class=\"string\">'&lt;/strong&gt;'</span>;     </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。<br>考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露”transitions”对象，使他们添加自己变换定义。插件中定义就像这样：<br>$.fn.cycle.transitions = { </p>\n<p>// … </p>\n<p>}; </p>\n<p>这个技巧使其他人能定义和传递变换设置到Cycle插件。</p>\n<h3 id=\"2-5-保持私有函数的私有性\"><a href=\"#2-5-保持私有函数的私有性\" class=\"headerlink\" title=\"2.5 保持私有函数的私有性\"></a>2.5 保持私有函数的私有性</h3><p>这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。</p>\n<p>那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。 </p>\n<p>Java代码<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (function($) &#123;     </div><div class=\"line\">  // plugin definition     </div><div class=\"line\">  $.fn.hilight = function(options) &#123;     </div><div class=\"line\">    debug(this);     </div><div class=\"line\">   // ...     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // private function <span class=\"keyword\">for</span> debugging     </div><div class=\"line\">  function debug($obj) &#123;     </div><div class=\"line\">    <span class=\"keyword\">if</span> (window.console &amp;&amp; window.console.log)     </div><div class=\"line\">    window.console.log(<span class=\"string\">'hilight selection count: '</span> + $obj.size());     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">//  ...     </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。</p>\n<h3 id=\"2-6-支持Metadata插件\"><a href=\"#2-6-支持Metadata插件\" class=\"headerlink\" title=\"2.6 支持Metadata插件\"></a>2.6 支持Metadata插件</h3><p>在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的”markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。</p>\n<p>Java代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.fn.hilight = function(options) &#123;     </div><div class=\"line\">  // ...     </div><div class=\"line\">  // build main options before element iteration     </div><div class=\"line\">  var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);     </div><div class=\"line\">  return this.each(function() &#123;     </div><div class=\"line\">    var $this = $(this);     </div><div class=\"line\">    // build element specific options     </div><div class=\"line\">    var o = $.meta ? $.extend(&#123;&#125;, opts, $this.data()) : opts;     </div><div class=\"line\">    //...</div></pre></td></tr></table></figure></p>\n<p> 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从”markup”处驱动行为,如果我们选择了“markup”：</p>\n<p> 调用的时候可以这样写： jQuery.foo(); 或 $.foo(); </p>\n<p>Java代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--  markup  --&gt;     </div><div class=\"line\">&lt;div class=\"hilight &#123; background: 'red', foreground: 'white' &#125;\"&gt;     </div><div class=\"line\">  Have a nice day!     </div><div class=\"line\">&lt;/div&gt;     </div><div class=\"line\">&lt;div class=\"hilight &#123; foreground: 'orange' &#125;\"&gt;     </div><div class=\"line\">  Have a nice day!     </div><div class=\"line\">&lt;/div&gt;     </div><div class=\"line\">&lt;div class=\"hilight &#123; background: 'green' &#125;\"&gt;     </div><div class=\"line\">  Have a nice day!     </div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>现在我们能高亮哪些div仅使用一行脚本：<br>$(‘.hilight’).hilight();     </p>\n<h3 id=\"2-7-整合\"><a href=\"#2-7-整合\" class=\"headerlink\" title=\"2.7 整合\"></a>2.7 整合</h3><p>下面使我们的例子完成后的代码：</p>\n<p>Java代码<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建一个闭包     </div><div class=\"line\">(function($) &#123;     </div><div class=\"line\">  // 插件的定义     </div><div class=\"line\">  $.fn.hilight = function(options) &#123;     </div><div class=\"line\">    debug(this);     </div><div class=\"line\">    // build main options before element iteration     </div><div class=\"line\">    var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);     </div><div class=\"line\">    // iterate and reformat each matched element     </div><div class=\"line\">    return this.each(function() &#123;     </div><div class=\"line\">    $this = $(this);     </div><div class=\"line\"> // build element specific options     </div><div class=\"line\"> var o = $.meta ? $.extend(&#123;&#125;, opts, $this.data()) : opts;     </div><div class=\"line\"> // update element styles     </div><div class=\"line\">$this.css(&#123;     </div><div class=\"line\">   backgroundColor: o.background,     </div><div class=\"line\">  color: o.foreground     </div><div class=\"line\">  &#125;);     </div><div class=\"line\">  var markup = $this.html();     </div><div class=\"line\">   // call our format function     </div><div class=\"line\"> markup = $.fn.hilight.format(markup);     </div><div class=\"line\"> $this.html(markup);     </div><div class=\"line\">    &#125;);     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // 私有函数：debugging     </div><div class=\"line\">  function debug($obj) &#123;     </div><div class=\"line\">    if (window.console &amp;&amp; window.console.log)     </div><div class=\"line\">      window.console.log('hilight selection count: ' + $obj.size());     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // 定义暴露format函数     </div><div class=\"line\">  $.fn.hilight.format = function(txt) &#123;     </div><div class=\"line\">    return '&lt;strong&gt;' + txt + '&lt;/strong&gt;';     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">  // 插件的defaults     </div><div class=\"line\">  $.fn.hilight.defaults = &#123;     </div><div class=\"line\">    foreground: 'red',     </div><div class=\"line\">    background: 'yellow'     </div><div class=\"line\">  &#125;;     </div><div class=\"line\">// 闭包结束     </div><div class=\"line\">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>\n<p>这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。</p>\n"},{"title":"Technical Term","date":"2016-12-14T01:10:25.000Z","_content":"\n\n###模块规范\n\n* CommonJS - 规范了js在任何地方运行，不限于浏览器中，定义的模块为模块引用（require）、模块定义（exports）、模块标识（module）,NodeJs就是基于CommonJs做了一些取舍和补充的重要应用。\n* AMD - 异步模块加载，接口为define(id?,dependencies?,factory),需要声明模块的时候制定所有以来dep，并且作为形参传入factory中，例如definr(['dep1','dep2'],function(dep1,dep2){...});RequireJS实现了AMD规范\n* CMD\n\n###专业术语\n* module bundler - 模块打包\n* flexible - 灵活\n* unbiased - 无偏\n* extensible - 可扩展的\n* framework - 框架\n \n ","source":"_posts/Technical-Term.md","raw":"---\ntitle: Technical Term\ndate: 2016-12-14 09:10:25\ntags:\n---\n\n\n###模块规范\n\n* CommonJS - 规范了js在任何地方运行，不限于浏览器中，定义的模块为模块引用（require）、模块定义（exports）、模块标识（module）,NodeJs就是基于CommonJs做了一些取舍和补充的重要应用。\n* AMD - 异步模块加载，接口为define(id?,dependencies?,factory),需要声明模块的时候制定所有以来dep，并且作为形参传入factory中，例如definr(['dep1','dep2'],function(dep1,dep2){...});RequireJS实现了AMD规范\n* CMD\n\n###专业术语\n* module bundler - 模块打包\n* flexible - 灵活\n* unbiased - 无偏\n* extensible - 可扩展的\n* framework - 框架\n \n ","slug":"Technical-Term","published":1,"updated":"2016-12-16T07:58:07.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwriz8000001tojoftgtqx5x"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-12-13T07:22:20.237Z","updated":"2016-12-13T07:22:20.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwriz8030002tojof97gqran"},{"title":"js自执行函数","date":"2016-12-15T06:59:19.000Z","_content":"js自执行函数的几种不同写法的比较\n\n经常需要一个函数自执行，可惜这一种写法是错的： \n复制代码 代码如下:\n```python\nfunction(){alert(1);}(); \n```\n\n原因是前半段“function(){alert(1);}”被当成了函数声明，而不是一个函数表达式，从而让后面的“();”变得孤立，产生语法错。 \n\n按上面的分析，这一段代码虽说没有语法错，但也是不符合我们的预期的，因为这个函数并没有自执行。 \n复制代码 代码如下:\n\n```python\nfunction(){alert(1);}(1); \n```\n综上，症结在于，如何明确代码描述的是一个函数表达式，而不是函数声明语句。 \n正确的写法多种多样，也各有利弊： \n\n方法1：最前最后加括号 \n\n复制代码 代码如下:\n```python\n(function(){alert(1);}()); \n```\n这是jslint推荐的写法，好处是，能提醒阅读代码的人，这段代码是一个整体。 \n例如，在有语法高亮匹配功能的编辑器里，光标在第一个左括号后时，最后一个右括号也会高亮，看代码的人一眼就可以看到这个整体。 \n不过，对于某些写代码不喜欢在行后加分号的同学，也会形成一些坑坑，例如以下代码会报运行错： \n复制代码 代码如下:\n```python\nvar a=1 \n(function(){alert(1);}()); \n```\n\n方法2：function外面加括号 \n\n复制代码 代码如下:\n```python\n(function(){alert(1);})(); \n```\n这种做法比方法1少了一个代码整体性的好处。 \n\n方法3：function前面加运算符，常见的是!与void 。 \n复制代码 代码如下:\n```python\n!function(){alert(1);}(); \nvoid function(){alert(2);}(); \n```\n\n显然，加上“!”或“+”等运算符，写起来是最简单的。 \n加上“void ”要敲五下键盘，但是听说有一个好处是，比加\"!\"少一次逻辑运算。----我只是听说，不明所以。 \n\n最后，代表我个人，强烈支持方法1,即jslint的推荐写法： \n复制代码 代码如下:\n```python\n(function(){alert(1);}()); \n```","source":"_posts/js自执行函数.md","raw":"---\ntitle: js自执行函数\ndate: 2016-12-15 14:59:19\ntags:\n---\njs自执行函数的几种不同写法的比较\n\n经常需要一个函数自执行，可惜这一种写法是错的： \n复制代码 代码如下:\n```python\nfunction(){alert(1);}(); \n```\n\n原因是前半段“function(){alert(1);}”被当成了函数声明，而不是一个函数表达式，从而让后面的“();”变得孤立，产生语法错。 \n\n按上面的分析，这一段代码虽说没有语法错，但也是不符合我们的预期的，因为这个函数并没有自执行。 \n复制代码 代码如下:\n\n```python\nfunction(){alert(1);}(1); \n```\n综上，症结在于，如何明确代码描述的是一个函数表达式，而不是函数声明语句。 \n正确的写法多种多样，也各有利弊： \n\n方法1：最前最后加括号 \n\n复制代码 代码如下:\n```python\n(function(){alert(1);}()); \n```\n这是jslint推荐的写法，好处是，能提醒阅读代码的人，这段代码是一个整体。 \n例如，在有语法高亮匹配功能的编辑器里，光标在第一个左括号后时，最后一个右括号也会高亮，看代码的人一眼就可以看到这个整体。 \n不过，对于某些写代码不喜欢在行后加分号的同学，也会形成一些坑坑，例如以下代码会报运行错： \n复制代码 代码如下:\n```python\nvar a=1 \n(function(){alert(1);}()); \n```\n\n方法2：function外面加括号 \n\n复制代码 代码如下:\n```python\n(function(){alert(1);})(); \n```\n这种做法比方法1少了一个代码整体性的好处。 \n\n方法3：function前面加运算符，常见的是!与void 。 \n复制代码 代码如下:\n```python\n!function(){alert(1);}(); \nvoid function(){alert(2);}(); \n```\n\n显然，加上“!”或“+”等运算符，写起来是最简单的。 \n加上“void ”要敲五下键盘，但是听说有一个好处是，比加\"!\"少一次逻辑运算。----我只是听说，不明所以。 \n\n最后，代表我个人，强烈支持方法1,即jslint的推荐写法： \n复制代码 代码如下:\n```python\n(function(){alert(1);}()); \n```","slug":"js自执行函数","published":1,"updated":"2016-12-16T08:01:44.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwriz8050003tojods71u0wr"},{"title":"回调函数","date":"2016-12-15T08:39:22.000Z","_content":"\n在JavaScrip中，function是内置的类对象，也就是说它是一种类型的对象，可以和其它String、Array、Number、Object类的对象一样用于内置对象的管理。因为function实际上是一种对象，它可以“存储在变量中，通过参数传递给(别一个)函数(function)，在函数内部创建，从函数中返回结果值”。\n因为function是内置对象，我们可以将它作为参数传递给另一个函数，延迟到函数中执行，甚至执行后将它返回。这是在JavaScript中使用回调函数的精髓。本篇文章的剩余部分将全面学习JavaScript的回调函数。回调函数也许是JavaScript中使用最广泛的功能性编程技术，也许仅仅一小段JavaScript或jQuery的代码都会给开发者留下一种神秘感，阅读这篇文章后，也许会帮你消除这种神秘感。\n回调函数来自一种著名的编程范式——函数式编程，在基本层面上，函数式编程指定的了函数的参数。函数式编程虽然现在的使用范围变小了，但它一直被“专业的聪明的”程序员看作是一种难懂的技术，以前是这样，未来也将是如此。\n\n幸运的是，函数式编程已经被阐述的像你我这样的一般人也能理解和使用。函数式编程最主要的技术之一就是回调函数，你很快会阅读到，实现回调函数就像传递一般的参数变量一样简单。这项技术如此的简单，以至于我都怀疑为什么它经常被包含在JavaScript的高级话题中去。\n\n什么是回调或高级函数?\n\n回调函数被认为是一种高级函数，一种被作为参数传递给另一个函数(在这称作\"otherFunction\")的高级函数，回调函数会在otherFunction内被调用(或执行)。回调函数的本质是一种模式(一种解决常见问题的模式)，因此回调函数也被称为回调模式。\n\n思考一下下面这种在jQuery中常用的回调函数：\n\n```python\n//Note that the item in the click method's parameter is a function, not a variable.\n//The item is a callback function\n$(\"#btn_1\").click(function() {\n  alert(\"Btn 1 Clicked\");\n});\n```\n正如在前面的例子所看到的，我们传递了一个函数给click方法的形参，click方法将会调用(或执行)我们传递给它的回调函数。这个例子就给出了JavaScript中使用回调函数的一个典型方式，并广泛应用于jQuery中。\n\n细细体味一下另一个基本JavaScript的典型例子：\n\n```python\nvar friends = [\"Mike\", \"Stacy\", \"Andy\", \"Rick\"];\n\nfriends.forEach(function (eachName, index){\nconsole.log(index + 1 + \". \" + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick\n});\n```\n我们再一次用同样的方式传递了一个匿名的函数(没有函数名的函数)给forEach方法，作为forEach的参数。\n\n到目前为止，我们传递了一个匿名的函数作为参数给另一个函数或方法。在看其它更复杂的回调函数之前，让我们理解一下回调的工作原理并实现一个自己的回调函数。\n\n回调函数是如何实现的？\n\n我们可以像使用变量一样使用函数，作为另一个函数的参数，在另一个函数中作为返回结果，在另一个函数中调用它。当我们作为参数传递一个回调函数给另一个函数时，我们只传递了这个函数的定义，并没有在参数中执行它。\n\n当包含(调用)函数拥有了在参数中定义的回调函数后，它可以在任何时候调用(也就是回调)它。\n\n这说明回调函数并不是立即执行，而是在包含函数的函数体内指定的位置“回调”它(形如其名)。所以，即使第一个jQuery的例子看起来是这样：\n```python\n//The anonymous function is not being executed there in the parameter. \n//The item is a callback function\n$(\"#btn_1\").click(function() {\n  alert(\"Btn 1 Clicked\");\n});\n```\n匿名函数将延迟在click函数的函数体内被调用，即使没有名称，也可以被包含函数通过 arguments对象访问。\n\n回调函数是闭包的\n当作为参数传递一个回调函数给另一个函数时，回调函数将在包含函数函数体内的某个位置被执行，就像回调函数在包含函数的函数体内定义一样。这意味着回调函数是闭包的，想更多地了解闭包，请参考作者另一个贴子Understand JavaScript Closures With Ease。从所周知，闭包函数可以访问包含函数的作用域，所以，回调函数可以访问包含函数的变量，甚至是全局变量。\n\n实现回调函数的基本原则\n\n简单地说，自己实现回调函数的时候需要遵循几条原则。\n\n使用命名函数或匿名函数作为回调\n在前面的jQuery和forEach的例子中，我们在包含函数的参数中定义匿名函数，这是使用回调函数的通用形式之一，另一个经常被使用的形式是定义一个带名称的函数，并将函数名作为参数传递给另一个函数，例如：\n```python\n // global variable\nvar allUserData = [];\n\n// generic logStuff function that prints to console\nfunction logStuff (userData) {\n    if ( typeof userData === \"string\")\n    {\n        console.log(userData);\n    }\n    else if ( typeof userData === \"object\")\n    {\n        for (var item in userData) {\n            console.log(item + \": \" + userData[item]);\n        }\n\n    }\n\n}\n\n// A function that takes two parameters, the last one a callback function\nfunction getInput (options, callback) {\n    allUserData.push (options);\n    callback (options);\n\n}\n\n// When we call the getInput function, we pass logStuff as a parameter.\n// So logStuff will be the function that will called back (or executed) inside the getInput function\ngetInput ({name:\"Rich\", speciality:\"JavaScript\"}, logStuff);\n//  name: Rich\n// speciality: JavaScript\n```\n传递参数给回调函数\n因为回调函数在执行的时候就和一般函数一样，我们可以传递参数给它。可以将包含函数的任何属性(或全局的属性)作为参数传递回调函数。在上一个例子中，我们将包含函数的options作为参数传递给回调函数。下面的例子让我们传递一个全局变量或本地变量给回调函数：\n```python\n//Global variable\nvar generalLastName = \"Clinton\";\n\nfunction getInput (options, callback) {\n    allUserData.push (options);\n// Pass the global variable generalLastName to the callback function\n    callback (generalLastName, options);\n}\n```\n在执行之前确保回调是一个函数\n在调用之前，确保通过参数传递进来的回调是一个需要的函数通常是明智的。此外，让回调函数是可选的也是一个好的实践。\n\n让我们重构一下上面例子中的getInput函数，确保回调函数做了适当的检查。\n```python\nfunction getInput(options, callback) {\n    allUserData.push(options);\n\n    // Make sure the callback is a function\n    if (typeof callback === \"function\") {\n    // Call it, since we have confirmed it is callable\n        callback(options);\n    }\n}\n```\n如果getInput函数没有做适当的检查(检查callback是否是函数，或是否通过参数传递进来了),我们的代码将会导致运行时错误。\n\n使用含有this对象的回调函数的问题\n当回调函数是一个含有this对象的方法时，我们必须修改执行回调函数的方法以保护this对象的内容。否则this对象将会指向全局的window对象(如果回调函数传递给了全局函数)，或指向包含函数。让我们看看下面的代码：\n```python\n// Define an object with some properties and a method\n// We will later pass the method as a callback function to another function\nvar clientData = {\n    id: 094545,\n    fullName: \"Not Set\",\n    // setUserName is a method on the clientData object\n    setUserName: function (firstName, lastName)  {\n        // this refers to the fullName property in this object\n      this.fullName = firstName + \" \" + lastName;\n    }\n}\n\nfunction getUserInput(firstName, lastName, callback)  {\n    // Do other stuff to validate firstName/lastName here\n\n    // Now save the names\n    callback (firstName, lastName);\n}\n```\n在下面的示例代码中，当clientData.setUserName被执行时，this.fullName不会设置clientData 对象中的属性fullName，而是设置window 对象中的fullName，因为getUserInput是一个全局函数。出现这种现象是因为在全局函数中this对象指向了window对象。\n```python\ngetUserInput (\"Barack\", \"Obama\", clientData.setUserName);\n\nconsole.log (clientData.fullName);// Not Set\n\n// The fullName property was initialized on the window object\nconsole.log (window.fullName); // Barack Obama\n```\n使用Call或Apply函数保护this对象\n\n我们可以通过使用 Call 或 Apply函数来解决前面示例中的问题。到目前为止，我们知道JavaScript中的每一个函数都有两个方法:Call和Apply。这些方法可以被用来在函数内部设置this对象的内容，并内容传递给函数参数指向的对象。\n\nCall takes the value to be used as the this object inside the function as the first parameter, and the remaining arguments to be passed to the function are passed individually (separated by commas of course). The Apply function’s first parameter is also the value to be used as the thisobject inside the function, while the last parameter is an array of values (or the arguments object) to pass to the function.  (该段翻译起来太拗口了，放原文自己体会)\n\n这听起来很复杂，但让我们看看Apply和Call的使用是多么容易。为解决前面例子中出现的问题，我们使用Apply函数如下：\n\n```python\n//Note that we have added an extra parameter for the callback object, called \"callbackObj\"\nfunction getUserInput(firstName, lastName, callback, callbackObj)  {\n    // Do other stuff to validate name here\n\n    // The use of the Apply function below will set the this object to be callbackObj\n    callback.apply (callbackObj, [firstName, lastName]);\n}\n```\n通过Apply函数正确地设置this对象，现在我们可以正确地执行回调函数并它正确地设置clientData对象中的fullName属性。\n```python\n// We pass the clientData.setUserName method and the clientData object as parameters. The clientData object will be used by the Apply function to set the this object\n getUserInput (\"Barack\", \"Obama\", clientData.setUserName, clientData);\n\n// the fullName property on the clientData was correctly set\nconsole.log (clientData.fullName); // Barack Obama\n```\n我们也可以使用Call 函数，但在本例中我们使用的Apply 函数。\n\n多重回调函数也是允许的\n我们可以传递多个回调函数给另一个函数，就像传递多个变量一样。这是使用jQuery的AJAX函数的典型例子：\n```python\nfunction successCallback() {\n    // Do stuff before send\n}\n\nfunction successCallback() {\n    // Do stuff if success message received\n}\n\nfunction completeCallback() {\n    // Do stuff upon completion\n}\n\nfunction errorCallback() {\n    // Do stuff if error received\n}\n\n$.ajax({\n    url:\"http://fiddle.jshell.net/favicon.png\",\n    success:successCallback,\n    complete:completeCallback,\n    error:errorCallback\n\n});\n```\n“回调地狱”的问题和解决方案\n\n异步代码执行是一种简单的以任意顺序执行的方式，有时是很常见的有很多层级的回调函数，你看起来像下面这样的代码。下面这种凌乱的代码称作“回调地狱”，因为它是一种包含非常多的回调的麻烦的代码。我是在node-MongoDB-native里看到这个例子的，MongoDB驱动Node.js.示例代码就像这样：\n```python\nvar p_client = new Db('integration_tests_20', new Server(\"127.0.0.1\", 27017, {}), {'pk':CustomPKFactory});\np_client.open(function(err, p_client) {\n    p_client.dropDatabase(function(err, done) {\n        p_client.createCollection('test_custom_key', function(err, collection) {\n            collection.insert({'a':1}, function(err, docs) {\n                collection.find({'_id':new ObjectID(\"aaaaaaaaaaaa\")}, function(err, cursor) {\n                    cursor.toArray(function(err, items) {\n                        test.assertEquals(1, items.length);\n\n                        // Let's close the db\n                        p_client.close();\n                    });\n                });\n            });\n        });\n    });\n});\n```\n你不太可能在自己的代码里碰到这个的问题，但如果你碰到了(或以后偶然碰到了)，那么有以下两种方式解决这个问题。\n\n命名并定义你的函数，然后传递函数名作为回调，而不是在主函数的参数列表里定义一个匿名函数。\n模块化：把你的代码划分成一个个模块，这样你可以空出一部分代码块做特殊的工作。然后你可以将这个模型引入到你的大型应用程序中。\n\n实现自己的回调函数\n\n现在你已经完全理解(我相信你已经理解了，如果没有请快速重新阅读一遍)了JavaScript关于回调的所用特性并且看到回调的使用是如此简单但功能却很强大。你应该看看自己的代码是否有机会使用回调函数，有以下需求时你可以考虑使用回调：\n\n避免重复代码 (DRY—Do Not Repeat Yourself)\n在你需要更多的通用功能的地方更好地实现抽象(可处理各种类型的函数)。\n增强代码的可维护性\n增强代码的可读性\n有更多定制的功能\n实现自己的回调函数很简单，在下面的例子中，我可以创建一个函数完成所用的工作：获取用户数据，使用用户数据生成一首通用的诗，使用用户数据来欢迎用户，但这个函数将会是一个凌乱的函数，到处是if/else的判断，甚至会有很多的限制并无法执行应用程序可能需要的处理用户数据的其它函数。\n\n替而代之的是我让实现增加了回调函数，这样主函数获取用户数据后可以传递用户全名和性别给回调函数的参数并执行回调函数以完成任何任务。\n\n简而言之，getUserInput函数是通用的，它可以执行多个拥有各种功能的回调函数。\n```python\n// First, setup the generic poem creator function; it will be the callback function in the getUserInput function below.\nfunction genericPoemMaker(name, gender) {\n    console.log(name + \" is finer than fine wine.\");\n    console.log(\"Altruistic and noble for the modern time.\");\n    console.log(\"Always admirably adorned with the latest style.\");\n    console.log(\"A \" + gender + \" of unfortunate tragedies who still manages a perpetual smile\");\n}\n\n//The callback, which is the last item in the parameter, will be our genericPoemMaker function we defined above.\nfunction getUserInput(firstName, lastName, gender, callback) {\n    var fullName = firstName + \" \" + lastName;\n\n    // Make sure the callback is a function\n    if (typeof callback === \"function\") {\n    // Execute the callback function and pass the parameters to it\n    callback(fullName, gender);\n    }\n}\n```\n调用getUserInput函数并传递genericPoemMaker函数作为回调：\n```python\ngetUserInput(\"Michael\", \"Fassbender\", \"Man\", genericPoemMaker);\n// Output\n/* Michael Fassbender is finer than fine wine.\nAltruistic and noble for the modern time.\nAlways admirably adorned with the latest style.\nA Man of unfortunate tragedies who still manages a perpetual smile.\n*/\n```\n因为getUserInput 函数只处理用户数据的输入，我们可以传递任何回调函数给它。例如我们可以像这样传递一个greetUser函数。\n```python\nfunction greetUser(customerName, sex)  {\n   var salutation  = sex && sex === \"Man\" ? \"Mr.\" : \"Ms.\";\n  console.log(\"Hello, \" + salutation + \" \" + customerName);\n}\n\n// Pass the greetUser function as a callback to getUserInput\ngetUserInput(\"Bill\", \"Gates\", \"Man\", greetUser);\n\n// And this is the output\n```\nHello, Mr. Bill Gates\n和上一个例子一样，我们调用了同一个getUserInput 函数，但这次却执行了完全不同的任务。\n\n如你所见，回调函数提供了广泛的功能。尽管前面提到的例子非常简单，在你开始使用回调函数的时候思考一下你可以节省多少工作，如何更好地抽象你的代码。加油吧！在早上起来时想一想，在晚上睡觉前想一想，在你休息时想一想\n\n我们在JavaScript中经常使用回调函数时注意以下几点，尤其是现在的web应用开发，在第三方库和框架中\n\n异步执行(例如读文件，发送HTTP请求)\n事件监听和处理\n设置超时和时间间隔的方法\n通用化：代码简洁 ","source":"_posts/回调函数.md","raw":"---\ntitle: 回调函数\ndate: 2016-12-15 16:39:22\ntags:\n---\n\n在JavaScrip中，function是内置的类对象，也就是说它是一种类型的对象，可以和其它String、Array、Number、Object类的对象一样用于内置对象的管理。因为function实际上是一种对象，它可以“存储在变量中，通过参数传递给(别一个)函数(function)，在函数内部创建，从函数中返回结果值”。\n因为function是内置对象，我们可以将它作为参数传递给另一个函数，延迟到函数中执行，甚至执行后将它返回。这是在JavaScript中使用回调函数的精髓。本篇文章的剩余部分将全面学习JavaScript的回调函数。回调函数也许是JavaScript中使用最广泛的功能性编程技术，也许仅仅一小段JavaScript或jQuery的代码都会给开发者留下一种神秘感，阅读这篇文章后，也许会帮你消除这种神秘感。\n回调函数来自一种著名的编程范式——函数式编程，在基本层面上，函数式编程指定的了函数的参数。函数式编程虽然现在的使用范围变小了，但它一直被“专业的聪明的”程序员看作是一种难懂的技术，以前是这样，未来也将是如此。\n\n幸运的是，函数式编程已经被阐述的像你我这样的一般人也能理解和使用。函数式编程最主要的技术之一就是回调函数，你很快会阅读到，实现回调函数就像传递一般的参数变量一样简单。这项技术如此的简单，以至于我都怀疑为什么它经常被包含在JavaScript的高级话题中去。\n\n什么是回调或高级函数?\n\n回调函数被认为是一种高级函数，一种被作为参数传递给另一个函数(在这称作\"otherFunction\")的高级函数，回调函数会在otherFunction内被调用(或执行)。回调函数的本质是一种模式(一种解决常见问题的模式)，因此回调函数也被称为回调模式。\n\n思考一下下面这种在jQuery中常用的回调函数：\n\n```python\n//Note that the item in the click method's parameter is a function, not a variable.\n//The item is a callback function\n$(\"#btn_1\").click(function() {\n  alert(\"Btn 1 Clicked\");\n});\n```\n正如在前面的例子所看到的，我们传递了一个函数给click方法的形参，click方法将会调用(或执行)我们传递给它的回调函数。这个例子就给出了JavaScript中使用回调函数的一个典型方式，并广泛应用于jQuery中。\n\n细细体味一下另一个基本JavaScript的典型例子：\n\n```python\nvar friends = [\"Mike\", \"Stacy\", \"Andy\", \"Rick\"];\n\nfriends.forEach(function (eachName, index){\nconsole.log(index + 1 + \". \" + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick\n});\n```\n我们再一次用同样的方式传递了一个匿名的函数(没有函数名的函数)给forEach方法，作为forEach的参数。\n\n到目前为止，我们传递了一个匿名的函数作为参数给另一个函数或方法。在看其它更复杂的回调函数之前，让我们理解一下回调的工作原理并实现一个自己的回调函数。\n\n回调函数是如何实现的？\n\n我们可以像使用变量一样使用函数，作为另一个函数的参数，在另一个函数中作为返回结果，在另一个函数中调用它。当我们作为参数传递一个回调函数给另一个函数时，我们只传递了这个函数的定义，并没有在参数中执行它。\n\n当包含(调用)函数拥有了在参数中定义的回调函数后，它可以在任何时候调用(也就是回调)它。\n\n这说明回调函数并不是立即执行，而是在包含函数的函数体内指定的位置“回调”它(形如其名)。所以，即使第一个jQuery的例子看起来是这样：\n```python\n//The anonymous function is not being executed there in the parameter. \n//The item is a callback function\n$(\"#btn_1\").click(function() {\n  alert(\"Btn 1 Clicked\");\n});\n```\n匿名函数将延迟在click函数的函数体内被调用，即使没有名称，也可以被包含函数通过 arguments对象访问。\n\n回调函数是闭包的\n当作为参数传递一个回调函数给另一个函数时，回调函数将在包含函数函数体内的某个位置被执行，就像回调函数在包含函数的函数体内定义一样。这意味着回调函数是闭包的，想更多地了解闭包，请参考作者另一个贴子Understand JavaScript Closures With Ease。从所周知，闭包函数可以访问包含函数的作用域，所以，回调函数可以访问包含函数的变量，甚至是全局变量。\n\n实现回调函数的基本原则\n\n简单地说，自己实现回调函数的时候需要遵循几条原则。\n\n使用命名函数或匿名函数作为回调\n在前面的jQuery和forEach的例子中，我们在包含函数的参数中定义匿名函数，这是使用回调函数的通用形式之一，另一个经常被使用的形式是定义一个带名称的函数，并将函数名作为参数传递给另一个函数，例如：\n```python\n // global variable\nvar allUserData = [];\n\n// generic logStuff function that prints to console\nfunction logStuff (userData) {\n    if ( typeof userData === \"string\")\n    {\n        console.log(userData);\n    }\n    else if ( typeof userData === \"object\")\n    {\n        for (var item in userData) {\n            console.log(item + \": \" + userData[item]);\n        }\n\n    }\n\n}\n\n// A function that takes two parameters, the last one a callback function\nfunction getInput (options, callback) {\n    allUserData.push (options);\n    callback (options);\n\n}\n\n// When we call the getInput function, we pass logStuff as a parameter.\n// So logStuff will be the function that will called back (or executed) inside the getInput function\ngetInput ({name:\"Rich\", speciality:\"JavaScript\"}, logStuff);\n//  name: Rich\n// speciality: JavaScript\n```\n传递参数给回调函数\n因为回调函数在执行的时候就和一般函数一样，我们可以传递参数给它。可以将包含函数的任何属性(或全局的属性)作为参数传递回调函数。在上一个例子中，我们将包含函数的options作为参数传递给回调函数。下面的例子让我们传递一个全局变量或本地变量给回调函数：\n```python\n//Global variable\nvar generalLastName = \"Clinton\";\n\nfunction getInput (options, callback) {\n    allUserData.push (options);\n// Pass the global variable generalLastName to the callback function\n    callback (generalLastName, options);\n}\n```\n在执行之前确保回调是一个函数\n在调用之前，确保通过参数传递进来的回调是一个需要的函数通常是明智的。此外，让回调函数是可选的也是一个好的实践。\n\n让我们重构一下上面例子中的getInput函数，确保回调函数做了适当的检查。\n```python\nfunction getInput(options, callback) {\n    allUserData.push(options);\n\n    // Make sure the callback is a function\n    if (typeof callback === \"function\") {\n    // Call it, since we have confirmed it is callable\n        callback(options);\n    }\n}\n```\n如果getInput函数没有做适当的检查(检查callback是否是函数，或是否通过参数传递进来了),我们的代码将会导致运行时错误。\n\n使用含有this对象的回调函数的问题\n当回调函数是一个含有this对象的方法时，我们必须修改执行回调函数的方法以保护this对象的内容。否则this对象将会指向全局的window对象(如果回调函数传递给了全局函数)，或指向包含函数。让我们看看下面的代码：\n```python\n// Define an object with some properties and a method\n// We will later pass the method as a callback function to another function\nvar clientData = {\n    id: 094545,\n    fullName: \"Not Set\",\n    // setUserName is a method on the clientData object\n    setUserName: function (firstName, lastName)  {\n        // this refers to the fullName property in this object\n      this.fullName = firstName + \" \" + lastName;\n    }\n}\n\nfunction getUserInput(firstName, lastName, callback)  {\n    // Do other stuff to validate firstName/lastName here\n\n    // Now save the names\n    callback (firstName, lastName);\n}\n```\n在下面的示例代码中，当clientData.setUserName被执行时，this.fullName不会设置clientData 对象中的属性fullName，而是设置window 对象中的fullName，因为getUserInput是一个全局函数。出现这种现象是因为在全局函数中this对象指向了window对象。\n```python\ngetUserInput (\"Barack\", \"Obama\", clientData.setUserName);\n\nconsole.log (clientData.fullName);// Not Set\n\n// The fullName property was initialized on the window object\nconsole.log (window.fullName); // Barack Obama\n```\n使用Call或Apply函数保护this对象\n\n我们可以通过使用 Call 或 Apply函数来解决前面示例中的问题。到目前为止，我们知道JavaScript中的每一个函数都有两个方法:Call和Apply。这些方法可以被用来在函数内部设置this对象的内容，并内容传递给函数参数指向的对象。\n\nCall takes the value to be used as the this object inside the function as the first parameter, and the remaining arguments to be passed to the function are passed individually (separated by commas of course). The Apply function’s first parameter is also the value to be used as the thisobject inside the function, while the last parameter is an array of values (or the arguments object) to pass to the function.  (该段翻译起来太拗口了，放原文自己体会)\n\n这听起来很复杂，但让我们看看Apply和Call的使用是多么容易。为解决前面例子中出现的问题，我们使用Apply函数如下：\n\n```python\n//Note that we have added an extra parameter for the callback object, called \"callbackObj\"\nfunction getUserInput(firstName, lastName, callback, callbackObj)  {\n    // Do other stuff to validate name here\n\n    // The use of the Apply function below will set the this object to be callbackObj\n    callback.apply (callbackObj, [firstName, lastName]);\n}\n```\n通过Apply函数正确地设置this对象，现在我们可以正确地执行回调函数并它正确地设置clientData对象中的fullName属性。\n```python\n// We pass the clientData.setUserName method and the clientData object as parameters. The clientData object will be used by the Apply function to set the this object\n getUserInput (\"Barack\", \"Obama\", clientData.setUserName, clientData);\n\n// the fullName property on the clientData was correctly set\nconsole.log (clientData.fullName); // Barack Obama\n```\n我们也可以使用Call 函数，但在本例中我们使用的Apply 函数。\n\n多重回调函数也是允许的\n我们可以传递多个回调函数给另一个函数，就像传递多个变量一样。这是使用jQuery的AJAX函数的典型例子：\n```python\nfunction successCallback() {\n    // Do stuff before send\n}\n\nfunction successCallback() {\n    // Do stuff if success message received\n}\n\nfunction completeCallback() {\n    // Do stuff upon completion\n}\n\nfunction errorCallback() {\n    // Do stuff if error received\n}\n\n$.ajax({\n    url:\"http://fiddle.jshell.net/favicon.png\",\n    success:successCallback,\n    complete:completeCallback,\n    error:errorCallback\n\n});\n```\n“回调地狱”的问题和解决方案\n\n异步代码执行是一种简单的以任意顺序执行的方式，有时是很常见的有很多层级的回调函数，你看起来像下面这样的代码。下面这种凌乱的代码称作“回调地狱”，因为它是一种包含非常多的回调的麻烦的代码。我是在node-MongoDB-native里看到这个例子的，MongoDB驱动Node.js.示例代码就像这样：\n```python\nvar p_client = new Db('integration_tests_20', new Server(\"127.0.0.1\", 27017, {}), {'pk':CustomPKFactory});\np_client.open(function(err, p_client) {\n    p_client.dropDatabase(function(err, done) {\n        p_client.createCollection('test_custom_key', function(err, collection) {\n            collection.insert({'a':1}, function(err, docs) {\n                collection.find({'_id':new ObjectID(\"aaaaaaaaaaaa\")}, function(err, cursor) {\n                    cursor.toArray(function(err, items) {\n                        test.assertEquals(1, items.length);\n\n                        // Let's close the db\n                        p_client.close();\n                    });\n                });\n            });\n        });\n    });\n});\n```\n你不太可能在自己的代码里碰到这个的问题，但如果你碰到了(或以后偶然碰到了)，那么有以下两种方式解决这个问题。\n\n命名并定义你的函数，然后传递函数名作为回调，而不是在主函数的参数列表里定义一个匿名函数。\n模块化：把你的代码划分成一个个模块，这样你可以空出一部分代码块做特殊的工作。然后你可以将这个模型引入到你的大型应用程序中。\n\n实现自己的回调函数\n\n现在你已经完全理解(我相信你已经理解了，如果没有请快速重新阅读一遍)了JavaScript关于回调的所用特性并且看到回调的使用是如此简单但功能却很强大。你应该看看自己的代码是否有机会使用回调函数，有以下需求时你可以考虑使用回调：\n\n避免重复代码 (DRY—Do Not Repeat Yourself)\n在你需要更多的通用功能的地方更好地实现抽象(可处理各种类型的函数)。\n增强代码的可维护性\n增强代码的可读性\n有更多定制的功能\n实现自己的回调函数很简单，在下面的例子中，我可以创建一个函数完成所用的工作：获取用户数据，使用用户数据生成一首通用的诗，使用用户数据来欢迎用户，但这个函数将会是一个凌乱的函数，到处是if/else的判断，甚至会有很多的限制并无法执行应用程序可能需要的处理用户数据的其它函数。\n\n替而代之的是我让实现增加了回调函数，这样主函数获取用户数据后可以传递用户全名和性别给回调函数的参数并执行回调函数以完成任何任务。\n\n简而言之，getUserInput函数是通用的，它可以执行多个拥有各种功能的回调函数。\n```python\n// First, setup the generic poem creator function; it will be the callback function in the getUserInput function below.\nfunction genericPoemMaker(name, gender) {\n    console.log(name + \" is finer than fine wine.\");\n    console.log(\"Altruistic and noble for the modern time.\");\n    console.log(\"Always admirably adorned with the latest style.\");\n    console.log(\"A \" + gender + \" of unfortunate tragedies who still manages a perpetual smile\");\n}\n\n//The callback, which is the last item in the parameter, will be our genericPoemMaker function we defined above.\nfunction getUserInput(firstName, lastName, gender, callback) {\n    var fullName = firstName + \" \" + lastName;\n\n    // Make sure the callback is a function\n    if (typeof callback === \"function\") {\n    // Execute the callback function and pass the parameters to it\n    callback(fullName, gender);\n    }\n}\n```\n调用getUserInput函数并传递genericPoemMaker函数作为回调：\n```python\ngetUserInput(\"Michael\", \"Fassbender\", \"Man\", genericPoemMaker);\n// Output\n/* Michael Fassbender is finer than fine wine.\nAltruistic and noble for the modern time.\nAlways admirably adorned with the latest style.\nA Man of unfortunate tragedies who still manages a perpetual smile.\n*/\n```\n因为getUserInput 函数只处理用户数据的输入，我们可以传递任何回调函数给它。例如我们可以像这样传递一个greetUser函数。\n```python\nfunction greetUser(customerName, sex)  {\n   var salutation  = sex && sex === \"Man\" ? \"Mr.\" : \"Ms.\";\n  console.log(\"Hello, \" + salutation + \" \" + customerName);\n}\n\n// Pass the greetUser function as a callback to getUserInput\ngetUserInput(\"Bill\", \"Gates\", \"Man\", greetUser);\n\n// And this is the output\n```\nHello, Mr. Bill Gates\n和上一个例子一样，我们调用了同一个getUserInput 函数，但这次却执行了完全不同的任务。\n\n如你所见，回调函数提供了广泛的功能。尽管前面提到的例子非常简单，在你开始使用回调函数的时候思考一下你可以节省多少工作，如何更好地抽象你的代码。加油吧！在早上起来时想一想，在晚上睡觉前想一想，在你休息时想一想\n\n我们在JavaScript中经常使用回调函数时注意以下几点，尤其是现在的web应用开发，在第三方库和框架中\n\n异步执行(例如读文件，发送HTTP请求)\n事件监听和处理\n设置超时和时间间隔的方法\n通用化：代码简洁 ","slug":"回调函数","published":1,"updated":"2016-12-16T08:20:44.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwriz8050004tojocddl2aim"},{"title":"Jquery简写","date":"2016-12-15T06:49:37.000Z","_content":"## ~ function($) {}($) \n```python\nvar fn = function(opt){};\nfn($);\n```\n## $this和$(this)\n// this其实是一个Html 元素。\n// $this 只是个变量名，加$是为说明其是个jquery对象。\n// 而$(this)是个转换，将this表示的dom对象转为jquery对象，这样就可以使用jquery提供的方法操作。\n\n## return this.each(function () {})\n因为each返回的也是this对象，所以直接return this.each可以执行你的相关操作，还可以保持链式调用功能\n因为this.each保证了遍历完成才执行下一个操作，否则迭代是延迟执行的，前面的插件并没有实际执行。\n```python\njQuery.fn.test2= function(){ \n   this.css(\"background\",\"#ff0\");//这里面的this为jquery对象，而不是dom对象 \n   return this.each(function(){ //遍历匹配的元素，此处的this表示为jquery对象，而不是dom对象 \n    alert(\"this\"+this+this.innerHTML); \n    //提示当前对象的dom节点名称,这里的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。 \n     }); \n};\n```\nthis.css(),this.each（）里面的this为jquery对象，但是alert里面this为dom对象.\n为什么要return this.each()\n先return this.each(),后调用each（）方法，而each（）方法返回jQuery对象，所以这样就可以继续链式操作了。\n首先在JQ中,each是遍历一个数组,比如你$('.some')返回的不一定只是一个jq对象,有可能是个数组,好多个elements.\n所以return this.each(){}是把所有你索引的对象都作用到这个插件下.\n你若保证你的插件每次都只会用一个JQ对象,那么你可以直接return this.\n\n\n## JavaScript prototype 属性\n定义和用法\nprototype 属性允许您向对象添加属性和方法\n注意： Prototype 是全局属性，适用于所有的Javascript对象。\n语法\nobject.prototype.name=value\n\n## _.extend\n_，在这里应该是接管了JQUERY，就是jQuery。(有不少人这样用，因为和$冲突)\n_.extend方法是把指定的对象进行扩展(在这里就是document.body.style)\nQuery中需要用到$符号，如果其他js库（例如大名鼎鼎的prototype)也定义了$符号，那么就会造成冲突，会影响到js代码的正常执行。\n\n## jquery call方法和apply方法\ncall方法: \n语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]]) \n定义：调用一个对象的一个方法，以另一个对象替换当前对象。 \n说明： \ncall 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 \n如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 \n\napply方法： \n语法：apply([thisObj[,argArray]]) \n定义：应用某一对象的一个方法，用另一个对象替换当前对象。 \n说明： \n如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 \n如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 \n\n\n```python\n  \n    <script language=\"javascript\"><!--\n   \n    /**定义一个animal类*/  \n    function Animal(){   \n    this.name = \"Animal\";   \n    this.showName = function(){   \n    alert(this.name);   \n    }   \n    }   \n    /**定义一个Cat类*/  \n    function Cat(){   \n    this.name = \"Cat\";   \n    }   \n  \n    /**创建两个类对象*/  \n    var animal = new Animal();   \n    var cat = new Cat();   \n  \n    //通过call或apply方法，将原本属于Animal对象的showName()方法交给当前对象cat来使用了。   \n    //输入结果为\"Cat\"   \n    animal.showName.call(cat,\",\");   \n    //animal.showName.apply(cat,[]);   \n      \n    \n// --></script> \n```","source":"_posts/Jquery简写.md","raw":"---\ntitle: Jquery简写\ndate: 2016-12-15 14:49:37\ntags:\n---\n## ~ function($) {}($) \n```python\nvar fn = function(opt){};\nfn($);\n```\n## $this和$(this)\n// this其实是一个Html 元素。\n// $this 只是个变量名，加$是为说明其是个jquery对象。\n// 而$(this)是个转换，将this表示的dom对象转为jquery对象，这样就可以使用jquery提供的方法操作。\n\n## return this.each(function () {})\n因为each返回的也是this对象，所以直接return this.each可以执行你的相关操作，还可以保持链式调用功能\n因为this.each保证了遍历完成才执行下一个操作，否则迭代是延迟执行的，前面的插件并没有实际执行。\n```python\njQuery.fn.test2= function(){ \n   this.css(\"background\",\"#ff0\");//这里面的this为jquery对象，而不是dom对象 \n   return this.each(function(){ //遍历匹配的元素，此处的this表示为jquery对象，而不是dom对象 \n    alert(\"this\"+this+this.innerHTML); \n    //提示当前对象的dom节点名称,这里的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。 \n     }); \n};\n```\nthis.css(),this.each（）里面的this为jquery对象，但是alert里面this为dom对象.\n为什么要return this.each()\n先return this.each(),后调用each（）方法，而each（）方法返回jQuery对象，所以这样就可以继续链式操作了。\n首先在JQ中,each是遍历一个数组,比如你$('.some')返回的不一定只是一个jq对象,有可能是个数组,好多个elements.\n所以return this.each(){}是把所有你索引的对象都作用到这个插件下.\n你若保证你的插件每次都只会用一个JQ对象,那么你可以直接return this.\n\n\n## JavaScript prototype 属性\n定义和用法\nprototype 属性允许您向对象添加属性和方法\n注意： Prototype 是全局属性，适用于所有的Javascript对象。\n语法\nobject.prototype.name=value\n\n## _.extend\n_，在这里应该是接管了JQUERY，就是jQuery。(有不少人这样用，因为和$冲突)\n_.extend方法是把指定的对象进行扩展(在这里就是document.body.style)\nQuery中需要用到$符号，如果其他js库（例如大名鼎鼎的prototype)也定义了$符号，那么就会造成冲突，会影响到js代码的正常执行。\n\n## jquery call方法和apply方法\ncall方法: \n语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]]) \n定义：调用一个对象的一个方法，以另一个对象替换当前对象。 \n说明： \ncall 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 \n如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 \n\napply方法： \n语法：apply([thisObj[,argArray]]) \n定义：应用某一对象的一个方法，用另一个对象替换当前对象。 \n说明： \n如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 \n如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 \n\n\n```python\n  \n    <script language=\"javascript\"><!--\n   \n    /**定义一个animal类*/  \n    function Animal(){   \n    this.name = \"Animal\";   \n    this.showName = function(){   \n    alert(this.name);   \n    }   \n    }   \n    /**定义一个Cat类*/  \n    function Cat(){   \n    this.name = \"Cat\";   \n    }   \n  \n    /**创建两个类对象*/  \n    var animal = new Animal();   \n    var cat = new Cat();   \n  \n    //通过call或apply方法，将原本属于Animal对象的showName()方法交给当前对象cat来使用了。   \n    //输入结果为\"Cat\"   \n    animal.showName.call(cat,\",\");   \n    //animal.showName.apply(cat,[]);   \n      \n    \n// --></script> \n```","slug":"Jquery简写","published":1,"updated":"2016-12-16T08:00:13.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwriz8070005tojorpz1xfor"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}